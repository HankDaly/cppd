# ex2_01
>int,long,long long,short的区别是什么

int是整型，最小尺寸16位
long是长整型，最小尺寸32位
long long是长整型，最小尺寸64位
short是短整型，最小尺寸16位
长整型至少和整型一样长，整型至少和短整型一样长
>无符号类型和带符号类型的区别是什么?

带符号类型可以表示正数,负数或0，无符号类型则仅能表示大于等于0的值。
>float和double的区别是什么?

float是单精度浮点数，最小位数是6位有效数字
double是双精度浮点数，最小位数是10位有效数字
通常在执行浮点数运算中选用double。
# ex2_02
>利率4.86%

适合用double双精度浮点数，考虑到不会为负可以加上unsigned
>本金10000

适合用int
>付款440.51

适合用double

# ex2_03&ex2_04
>输出结果
```
u2-u 输出:32
u-u2 输出:4294967264
i2-i 输出:32
i-i2 输出:-32
i-u  输出:0
u-i  输出:0
```
# ex2_05
>(a)

'a'--字符字面值,类型为char

L'a'--宽字符型字面值，类型是wchar_t

"a"--字符串字面值，是由常量字符构成的数组(array)

L"a"--宽字符串型字面值

宽字符与字符的区别在于所占的字符数，但实际上并没有规定char占几位，更多的区别在于本地化策略集对于二者做如何规定。
>(b)

10--整型字面值,类型是int

10u--无符号的整型字面值，类型是unsigned

10uL--无符号整型字面值，类型是unsigned long long

012--八进制数，表示十进制数的10

0xC--十六进制数
>(c)

3.14--浮点型字面值，类型为double

3.14f--浮点型字面值，类型为float

3.14L--浮点型字面值，类型为long double
>(d)

10--整型字面值,类型是int

10u--无符号的整型字面值，类型是unsigned

10.--浮点型字面值，类型是double

10e-2--浮点型字面值，类型是double

# ex2_06
有区别，9与7表示的十进制，而09与07表示的是八进制,然而八进制里面没有9这个数，所以用09初始化值会报错。

# ex2_07
>(a),输出:
```
Who goes with Fergus?
```
数据类型是字符串字面值，中间转义了字母e和一个换行符
>(b),输出:
```
31.4
```
数据类型是long double
>(c),报错:
```
unable to find numeric literal operator operator f
```
>(d),输出:
```
3.14
```
数据类型是long double

# ex2_09
>(a)

定义变量 input_value 为int类型

>(b)

错误，转换未执行，因为存在丢失信息的危险
应改为: int i = (3.14) or int i = 3.14

>(c)

错误，wage并没有定义，应该先初始化wage，然后将wage的值赋给salary

>(d)

将浮点数转化为整数

# ex2_10
global_str被定义为空串
global_int被定义为0
local_int未定义
local_str未定义

# ex2_11
(a)定义

(b)声明并定义

(c)声明

# ex2_12
非法: (b),(c),(d)

# ex2_13
j的值是42

# ex2_14
合法，输出100 45。

# ex2_15
(b)不合法，引用类型的初始值必须是一个对象

(d)不合法，引用类型必须初始化

# ex2_16
都合法

(a) r2作为d的引用，将3.14159的值赋给了d

(b) r1作为i的引用，将i的值赋给了d

(c)将d的值赋给了i

(d)将d的值赋给了i

